


#Software Engineering Day1 Assignment
#Anayo Stanley Anigo
#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is the process of developing, testing and deploying computer applications/softwares to solve real-world problems by adhering to a set of engineering principles and best practices. 
Technological advancements:Software engineering is the driving force for science and technology, it shapes our digital world, By leveraging software engineering principles, we can create innovative solutions that enhance productivity, communication, and overall user experience such as developing a cutting-edge applications eg artificial intelligence, machine learning and virtual reality which enhance the quality of life, optimise daily operations and management.


Identify and describe at least three key milestones in the evolution of software engineering.

1.Mastering the Machine (1956–1967): 
The discovery of first low-level Computer Aided Software Engineering tools (CASE tools) facilitating interactive editing, compiling, and debugging. The main purpose of any piece of software was to optimize exploitation of the limited hardware resources. The first compilers were defined; operating systems were noninteractive. 

2. Mastering the Process (1968–1982):
The first software crisis in this stage led to the birth of software engineering. The aim was to reduce risk during development and improve quality and productivity. Software development methodologies appeared to define and monitor software building. An important contribution of this stage was the formal modeling approach that enables implementation automation.

3. Mastering the Complexity (1983–1992):
The up to then dominion of hardware over software ended. Personal computers arrived and opened the fields of computer applications. The software development process would now comprehensively address analysis and design from the specification. Graphical user interface and visual programming brought software closer to customers.

4. Mastering the Communications (1993–2001):
The emergence of the Internet brought with it a new software concept. The decentralization of functions and data led to the rapid development and expansion of areas of computing, such as concurrent programming and distributed architectures, which up to then had been limited to a narrower context. In addition to client/server applications, and in general, any distributed system development, there was now a new engineering software discipline called Web engineering.

6. Mastering the Productivity (2002–2010):
Most software systems created in this stage are called management information systems. They were designed to be an important part of business management in large companies. This has led to a need for the methodologies to be adapted by increasing the abstraction levels in software engineering tasks up to the abstraction level in which the problem is described. New tools enabling analysis level programming, such as Model Driven Architecture (MDA) appeared in this stage. The other major significant period in this stage was marked by the emergence of agile methodologies.
  
8. Mastering the Market (2011– Till date):
It is based on the combination of basic services (own or outside) that provide the functionality at business level for a specific domain problem. These services are orchestrated to perform more complex tasks, becoming composite services.They tend to be more dynamic than traditional programs and are the ultimate expression of agile methods and MDA.


List and briefly explain the phases of the Software Development Life Cycle.

Phase 1: Planning
The initial stage of software development, Planning, involves defining the software's purpose and scope, much like pinpointing our destination and plotting the best route. 

Phase 2: Requirements Analysis
This SDLC phase seeks to identify and record the precise requirements of the final users. In this phase, the team is looking to answer, "What are the expectations of our users from our software?" This is called requirements gathering.

Phase 3: Design
The Design phase is all about building the framework. The development team is responsible for software engineering and outlines the software's functionality and aesthetic. This ultimately results in the software product. The emphasis lies on outlining the software's structure, navigation, user interfaces, and database design. This phase ensures that the software is user-friendly and performs its tasks efficiently.

Phase 4: Coding
The Coding phase in the Software Development Life Cycle (SDLC) is when engineers and developers start converting the software design into tangible code.
This development phase aims to develop software that is functional, efficient, and user-friendly. Developers use an appropriate programming language to write the code, guided by the SDD and coding guidelines. Thereby ensuring that the software aligns with the vision set in earlier phases.

Phase 5: Testing
Software testing involves a thorough examination of the software for any bugs or glitches that might have slipped through during coding. The aim is to ensure flawless software operation before it reaches the end-users.Testing phase of the SDLC are stringent quality inspection on a production line. It is use to uncover vulnerabilities in the software.

Phase 6: Deployment
The Deployment phase involves rolling out the meticulously tested and fine-tuned software to its end-users. After crafting a product with precision, it's time to present it to the users by pushing to the production environment. 

Phase 7: Maintenance
In the Software Development Life Cycle, the maintenance phase is characterized by constant assistance and improvement, which guarantees the software's best possible functioning and longevity and ensures it meets customer expectations.


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.


1. Roles: Waterfall strictly assigns roles to project team members, with specific duties and responsibilities defined for each team member. In contrast, the agile model empowers team members to collaborate on different aspects of the project over time, leading to a more self-organizing team structure.
2. Planning: In waterfall, planning is a linear process done at the beginning of the project, with all requirements and objectives laid out in detail upfront. In contrast, agile planning is a continuous process throughout the project's life cycle, with adjustments made as new information or requirements emerge.
3. Scope: The waterfall methodology generally discourages changes to the project's scope, even with change requests used correctly. This is because the methodology requires an extensive amount of time spent in the beginning trying to get the plan right, which can make changes more costly after the project has begun. On the other hand, agile is more adaptable to changes in scope, with the development team able to adjust quickly as requirements change.
4. Time frames: The waterfall method is designed for long-term projects with predetermined timelines. The project is completed linearly, with each phase dependent on the previous one. Agile, however, uses short iterations to deliver value rapidly, allowing teams to adjust plans over time and achieve shorter time frames.
5. Speed: Waterfall projects tend to take longer because all requirements must be agreed upon before development can begin. Agile projects, on the other hand, are usually delivered more rapidly than waterfall projects due to the iterative development cycles used in agile.
6. Delivery: Agile allows for quick delivery of projects with shorter lifecycles, as each iteration delivers a workable product. Waterfall requires the completion of all tasks before any work can be released.
7. Flexibility: Agile encourages teams to respond quickly and adaptively to changes during the development process. Waterfall is less flexible and resistant to change once the project's scope has been defined.
8. Testing: Testing is essential to the agile and waterfall methodologies, but the approaches differ significantly. Agile emphasizes incremental testing to identify and resolve issues throughout the development process. In waterfall, testing is usually done at specific milestones, often towards the end of the project.
9. Documentation: Agile relies on minimal documentation, focusing on self-organizing teams and collaboration. Waterfall, in contrast, relies heavily on documenting each step in detail to ensure that all team members are on the same page.
10.Communication: Agile emphasizes informal communication, with frequent interactions between individuals or small groups of stakeholders. In waterfall, communication is more formal, with detailed communication plans and progress reports shared across multiple stakeholders.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.


Software Developer: Software engineers who are familiar with the technologies required for the development of systems to build, deploy, integrate and administer back-end software and distributed systems are called DevOps engineers. They mostly manage the application infrastructure, i.e., the database systems, servers, etc.

Responsibilities :

Developing applications, programs and systems using programming languages and frameworks.
Maintaining and updating software to keep it functional.
Collaborating with other team members to ensure best practices when developing software.
Report to the project manager about the progress of the software development.  

Quality Assurance Engineer: The quality assurance engineer creates tests that identify issues with software before it is deployed. QA engineers monitor every phase of the software development process, including development, testing, debugging and delivery. They ensure that quality is maintained at every stage of the development process and that the final product meets the requirements.

Responsibilities:

Collaborate with stakeholders to understand and clarify software requirements.
Create development standards and procedures for the programmers to follow. 
Confirm that the software meets the requirements before deployment.
Analyse the product to identify bugs and suggest changes to make them more efficient. 
Develop and execute automation scripts using open-source tools. 

Project Manager: In software development, the roles of the project manager may include helping the team to design, execute, monitor and finish their work so that the clients will receive higher-quality software products. 

Responsibilities: 

Discuss the project and its requirements with clients and software developers.
Assemble and lead the software development team.
Create the blueprint for the project, including the scope, allocating resources, setting deadlines and laying out communication strategies.
Supervising each stage of the software development project.
Set the budget and ensure the project adheres to it as closely as possible.
Tracking and communicating information regarding the project milestones, deliverables and change requests.
Deliver the completed software to the client and regularly check its performance.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.


An integrated development environment (IDE) is a software application that helps programmers develop software code efficiently. It increases developer productivity by combining capabilities such as software editing, building, testing, and packaging in an easy-to-use application. software developers use IDEs to make their job easier. Examples of IDEs are Visual Studio Code, IntelliJ IDEA, Eclipse, Xcode, and Android Studio.
Version Control System (VCS) is crucial in software development as it efficiently manages and tracks changes to code over time, facilitating team collaboration and project progress tracking.
VCS primary function is to keep a Log of Changes/version history, is a record of all the modifications made to a software application and also to enhance software development workflow. Examples of VCS are GIT, SVN and Mercurial.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.


1. The Learning Curve
Mastering software development requires dedication due to its steep learning curve.
Professionals must learn programming Languages (Core languages such as Python, Java, and C++), Frameworks and Tools (React, Node.js, and cloud computing platforms like AWS), Core Concepts: Algorithms, data structures, and system design.
They need to continually adapt to evolving technologies adds complexity to the journey.

2. Problem-Solving Skills
Software engineers need to tackle intricate real-world problems. Examples include: Designing scalable e-commerce platforms. Developing algorithms for healthcare data analysis.
This requires logical thinking, creativity, and resilience.

3. The Complexity of Projects
Large-scale applications demand expertise in various area such System Architecture which will ensure robust and scalable designs.
Team Collaboration is needed to tackle these challenges: Working with cross-functional teams like designers and product managers.

4. Constant Evolution
New frameworks, tools, and technologies emerge frequently. Continuous learning is required to keep up with the new discovery. 



Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.


1. Unit tests
Unit tests are very low level and close to the source of an application. They consist in testing individual methods and functions of the classes, components, or modules used by your software. Unit tests are generally quite cheap to automate and can run very quickly by a continuous integration server. Unit testing is a crucial part of software development as it helps catch defects early in the process, reduce costs, improve code quality, and facilitate refactoring

2. Integration tests
Integration tests verify that different modules or services used by your application work well together. For example, it can be testing the interaction with the database or making sure that microservices work together as expected. These types of tests are more expensive to run as they require multiple parts of the application to be up and running. It prevents critical failures in production by addressing bugs before deployment.

3. Functional tests
Functional tests focus on the business requirements of an application. They only verify the output of an action and do not check the intermediate states of the system when performing that action.
There is sometimes a confusion between integration tests and functional tests as they both require multiple components to interact with each other. The difference is that an integration test may simply verify that you can query the database while a functional test would expect to get a specific value from the database as defined by the product requirements. The need for functional testing is vital in validating the quality and functionality of the software.

4. System testing
It iis also referred to as system-level testing or system integration testing. It is the process in which a quality assurance (QA) team evaluates how the various components of an application interact together in the full, integrated system or application.
System testing checks the system's functionality to fulfill all the business requirements.

5. Acceptance testing
Acceptance tests are formal tests that verify if a system satisfies business requirements. They require the entire application to be running while testing and focus on replicating user behaviors. But they can also go further and measure the performance of the system and reject changes if certain goals are not met. Acceptance testing is a crucial phase in the software development lifecycle, ensuring that the software meets business requirements and user expectations before release.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.


Prompt engineering is the practice of designing and refining prompts—questions or instructions—to elicit specific responses from AI models. It is a process where you guide generative artificial intelligence (generative AI) solutions to generate desired outputs.
The importance of prompt engineering include enhancing the capabilities of AI models, enabling them to perform tasks that were exclusively human domain. By Prompt engineering, AI models can generate creative text, translate languages, write different kinds of creative content, and answer your questions in an informative way. Prompt engineering can help mitigate biases and ensure that AI models produce outputs that are fair, equitable and inclusive. 

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.


Vague prompt: “Tips and tricks for a successful coding?”

Improved prompt:"How should I practice coding so that I write the best optimized code?"

The improved prompt is more effective because the machine language clearly understand the context of the input.
